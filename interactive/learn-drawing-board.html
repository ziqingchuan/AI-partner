<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é’‰å­æ¿AIå®éªŒå®¤ï¼ˆå¹³æ¿ä¸“ç”¨ç‰ˆï¼‰</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --bg-color: #f3f4f6;
            --panel-bg: #ffffff;
            --accent-red: #dc2626;
            --accent-green: #10b981;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* ç¦æ­¢æ•´ä¸ªé¡µé¢æ»šåŠ¨ */
            -webkit-user-select: none; /* ç¦æ­¢é€‰ä¸­æ–‡æœ¬ */
            user-select: none;
        }

        /* é¡¶éƒ¨å¯¼èˆªæ  */
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 100;
            height: 50px;
        }

        h1 { margin: 0; font-size: 1.1rem; font-weight: 600; }
        
        .mode-switch-container { display: flex; align-items: center; gap: 10px; }
        .switch { position: relative; display: inline-block; width: 60px; height: 32px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--accent-green);
            transition: .4s; border-radius: 34px;
        }
        .slider:before {
            position: absolute; content: ""; height: 24px; width: 24px;
            left: 4px; bottom: 4px; background-color: white;
            transition: .4s; border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input:checked + .slider { background-color: var(--accent-red); }
        input:checked + .slider:before { transform: translateX(28px); }
        .mode-label { font-weight: bold; font-size: 0.9rem; color: rgba(255,255,255,0.9); }

        /* ä¸»ä½“å¸ƒå±€ */
        main {
            flex: 1;
            display: flex;
            flex-direction: row;
            height: calc(100vh - 74px); /* å‡å»headeré«˜åº¦ */
            position: relative;
        }

        /* å·¦ä¾§ç”»å¸ƒåŒº */
        #canvas-container {
            flex: 1;
            position: relative;
            background-color: #fff;
            overflow: hidden;
            touch-action: none; /* å…³é”®ï¼šç¦æ­¢ç”»å¸ƒåŒºåŸŸçš„æ‰€æœ‰åŸç”Ÿè§¦æ‘¸è¡Œä¸º */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .guide-text {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.95);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #4b5563;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.05);
            white-space: nowrap;
        }

        /* å³ä¾§æ•°æ®é¢æ¿ */
        #data-panel {
            width: 280px;
            background-color: var(--panel-bg);
            border-left: 1px solid #e5e7eb;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 50;
            box-shadow: -4px 0 15px rgba(0,0,0,0.03);
        }

        .data-card {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 12px;
            text-align: center;
        }

        .data-card h3 { margin: 0 0 4px 0; color: #64748b; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px; }
        .data-value {
            font-size: 2.2rem;
            font-weight: 700;
            color: #111827;
            height: 40px;
            line-height: 40px;
            font-family: 'Courier New', monospace; /* æ•°å­—ç­‰å®½ï¼Œé˜²æ­¢è·³åŠ¨ */
        }

        .highlight-value { color: var(--primary-color); }

        /* æŒ‰é’®æ ·å¼ä¼˜åŒ– */
        .btn {
            border: none;
            border-radius: 10px;
            padding: 14px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
        }
        
        .btn:active { transform: scale(0.96); }

        .btn-reset { 
            background-color: #ef4444; 
            color: white; 
            margin-top: auto; 
            box-shadow: 0 4px 6px rgba(239, 68, 68, 0.2);
        }

        .btn-reveal {
            background-color: var(--primary-color);
            color: white;
            display: none;
            box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4); }
            70% { box-shadow: 0 0 0 8px rgba(37, 99, 235, 0); }
            100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
        }

        /* å¹³æ¿ç«–å±é€‚é… */
        @media (max-width: 820px) {
            main { flex-direction: column; }
            #data-panel { 
                width: auto;
                height: auto;
                flex-direction: row; 
                border-left: none; 
                border-top: 1px solid #e5e7eb;
                padding: 10px;
                gap: 10px;
            }
            .data-card { flex: 1; padding: 5px; }
            .data-value { font-size: 1.5rem; height: 30px; line-height: 30px; }
            .btn { width: auto; padding: 0 20px; font-size: 0.9rem; }
            .btn-reset { margin-top: 0; }
            #canvas-container { height: 65vh; }
        }
    </style>
</head>
<body>

<header>
    <h1>é’‰å­æ¿AIå®éªŒå®¤</h1>
    <div class="mode-switch-container">
        <span class="mode-label" id="mode-text">æ¢ç´¢æ¨¡å¼</span>
        <label class="switch">
            <input type="checkbox" id="mode-toggle">
            <span class="slider"></span>
        </label>
    </div>
</header>

<main>
    <div id="canvas-container">
        <div class="guide-text" id="guide">ğŸ‘† ç‚¹å‡»é’‰å­ç”»å›¾ï¼Œå›åˆ°èµ·ç‚¹é—­åˆ</div>
        <canvas id="board"></canvas>
    </div>

    <div id="data-panel">
        <div class="data-card">
            <h3>å†…éƒ¨é’‰å­æ•° (a)</h3>
            <div class="data-value" id="val-a">-</div>
        </div>
        <div class="data-card">
            <h3>è¾¹ä¸Šé’‰å­æ•° (n)</h3>
            <div class="data-value" id="val-n">-</div>
        </div>
        <div class="data-card">
            <h3>é¢ç§¯ (S)</h3>
            <div class="data-value highlight-value" id="val-s">-</div>
        </div>
        
        <button class="btn btn-reveal" id="btn-reveal" onclick="revealData()">ğŸ‘€ æ­æ™“</button>
        <button class="btn btn-reset" onclick="resetBoard()">ğŸ—‘ï¸ é‡ç”»</button>
    </div>
</main>

<script>
    // --- æ ¸å¿ƒé…ç½® ---
    const CONFIG = {
        gridSpacing: 40, // é€»è¾‘ç½‘æ ¼é—´è·
        dotRadius: 3,
        vertexRadius: 6,
        snapDistance: 20 // å¸é™„èŒƒå›´
    };

    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    
    // çŠ¶æ€å˜é‡
    let points = []; // å­˜å‚¨é€»è¾‘åæ ‡ {x, y}
    let isClosed = false;
    let isGuessMode = false;
    let computedData = { a: 0, n: 0, s: 0 };
    let dpr = 1; // è®¾å¤‡åƒç´ æ¯”

    // UI å…ƒç´ 
    const ui = {
        a: document.getElementById('val-a'),
        n: document.getElementById('val-n'),
        s: document.getElementById('val-s'),
        btnReveal: document.getElementById('btn-reveal'),
        guide: document.getElementById('guide'),
        modeText: document.getElementById('mode-text')
    };

    // --- åˆå§‹åŒ– ---
    function init() {
        setupHighDPICanvas();
        window.addEventListener('resize', () => {
            setupHighDPICanvas();
            draw();
        });

        // æ¨¡å¼åˆ‡æ¢ç›‘å¬
        document.getElementById('mode-toggle').addEventListener('change', (e) => {
            isGuessMode = e.target.checked;
            ui.modeText.textContent = isGuessMode ? "éªŒè¯æ¨¡å¼" : "æ¢ç´¢æ¨¡å¼";
            if (isClosed) updateUI();
        });

        // ç»Ÿä¸€å¤„ç†è§¦æ§å’Œé¼ æ ‡äº‹ä»¶
        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('mousedown', handleMouse);
    }

    // --- é«˜æ¸…å±é€‚é… (Retina) ---
    function setupHighDPICanvas() {
        const container = document.getElementById('canvas-container');
        const rect = container.getBoundingClientRect();
        
        dpr = window.devicePixelRatio || 1;
        
        // è®¾ç½®Canvasçš„å®é™…åƒç´ å¤§å°
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        
        // è®¾ç½®CSSå¤§å°
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;
        
        // ç¼©æ”¾ç»˜å›¾ä¸Šä¸‹æ–‡ï¼Œä½¿å¾—ç»˜å›¾é€»è¾‘ä»ç„¶åŸºäºCSSåƒç´ 
        ctx.scale(dpr, dpr);
        
        draw();
    }

    // --- äº‹ä»¶å¤„ç† ---
    function handleTouch(e) {
        e.preventDefault(); // é˜»æ­¢æ»šåŠ¨å’Œé»˜è®¤è¡Œä¸º
        const touch = e.touches[0];
        processInput(touch.clientX, touch.clientY);
    }

    function handleMouse(e) {
        processInput(e.clientX, e.clientY);
    }

    function processInput(clientX, clientY) {
        if (isClosed) return;

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        // å¯»æ‰¾æœ€è¿‘çš„ç½‘æ ¼ç‚¹ (å¸é™„ç®—æ³•)
        const gx = Math.round(x / CONFIG.gridSpacing);
        const gy = Math.round(y / CONFIG.gridSpacing);
        
        // æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦æœ‰æ•ˆï¼ˆåœ¨ç”»å¸ƒèŒƒå›´å†…ï¼‰
        const realX = gx * CONFIG.gridSpacing;
        const realY = gy * CONFIG.gridSpacing;
        
        // è¾¹ç•Œæ£€æŸ¥ï¼šé˜²æ­¢ç‚¹åˆ°ç”»å¸ƒè¾¹ç¼˜å¤ªè¿‘
        if (realX < CONFIG.gridSpacing || realX > rect.width - CONFIG.gridSpacing || 
            realY < CONFIG.gridSpacing || realY > rect.height - CONFIG.gridSpacing) {
            return;
        }

        // è·ç¦»æ£€æŸ¥ï¼šå¦‚æœç‚¹å‡»ä½ç½®ç¦»ç½‘æ ¼ç‚¹å¤ªè¿œï¼Œä¸å“åº”ï¼ˆé˜²è¯¯è§¦ï¼‰
        const dist = Math.hypot(x - realX, y - realY);
        if (dist > CONFIG.snapDistance) return;

        const newPoint = { x: gx, y: gy };

        // é€»è¾‘åˆ¤æ–­
        // 1. é—­åˆæ£€æµ‹
        if (points.length > 2 && newPoint.x === points[0].x && newPoint.y === points[0].y) {
            isClosed = true;
            calculate();
            draw();
            ui.guide.textContent = "âœ… å›¾å½¢å·²é—­åˆ";
            return;
        }

        // 2. é‡å¤ç‚¹æ£€æµ‹
        if (points.length > 0) {
            const last = points[points.length - 1];
            if (last.x === newPoint.x && last.y === newPoint.y) return;
        }

        points.push(newPoint);
        draw();
        updateGuide();
    }

    function updateGuide() {
        if (points.length === 0) ui.guide.textContent = "ğŸ‘† ç‚¹å‡»é’‰å­ç”»å›¾";
        else if (points.length < 3) ui.guide.textContent = "ğŸ‘‰ ç»§ç»­ç‚¹å‡»ä¸‹ä¸€ä¸ªé’‰å­";
        else ui.guide.textContent = "ğŸ”´ ç‚¹å‡»ç¬¬ä¸€ä¸ªçº¢ç‚¹å³å¯é—­åˆ";
    }

    // --- ç»˜å›¾é€»è¾‘ ---
    function draw() {
        const width = canvas.width / dpr;
        const height = canvas.height / dpr;

        ctx.clearRect(0, 0, width, height);
        
        // 1. ç”»ç½‘æ ¼
        ctx.fillStyle = '#9ca3af';
        for (let x = CONFIG.gridSpacing; x < width; x += CONFIG.gridSpacing) {
            for (let y = CONFIG.gridSpacing; y < height; y += CONFIG.gridSpacing) {
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2); // ç½‘æ ¼ç‚¹å°ä¸€ç‚¹ï¼Œè§†è§‰æ›´æ¸…çˆ½
                ctx.fill();
            }
        }

        if (points.length === 0) return;

        // 2. ç”»çº¿
        ctx.strokeStyle = '#2563eb';
        ctx.lineWidth = 3;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        
        const start = gridToPixel(points[0]);
        ctx.moveTo(start.x, start.y);

        for (let i = 1; i < points.length; i++) {
            const p = gridToPixel(points[i]);
            ctx.lineTo(p.x, p.y);
        }

        if (isClosed) {
            ctx.closePath();
            ctx.fillStyle = 'rgba(37, 99, 235, 0.15)';
            ctx.fill();
        }

        ctx.stroke();

        // 3. ç”»é¡¶ç‚¹
        for (let i = 0; i < points.length; i++) {
            const p = gridToPixel(points[i]);
            ctx.beginPath();
            // èµ·ç‚¹æ˜¾ç¤ºä¸ºçº¢è‰²ï¼Œå…¶ä»–è“è‰²
            ctx.fillStyle = (i === 0 && !isClosed) ? '#dc2626' : '#2563eb';
            // èµ·ç‚¹å¤§ä¸€ç‚¹
            const r = (i === 0 && !isClosed) ? 7 : 5;
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
            
            // é€‰ä¸­çš„ç‚¹åŠ ç™½è¾¹
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    function gridToPixel(p) {
        return { x: p.x * CONFIG.gridSpacing, y: p.y * CONFIG.gridSpacing };
    }

    function resetBoard() {
        points = [];
        isClosed = false;
        computedData = { a: 0, n: 0, s: 0 };
        ui.guide.textContent = "ğŸ‘† ç‚¹å‡»é’‰å­ç”»å›¾ï¼Œå›åˆ°èµ·ç‚¹é—­åˆ";
        ui.btnReveal.style.display = 'none';
        
        ui.a.textContent = '-';
        ui.n.textContent = '-';
        ui.s.textContent = '-';
        ui.s.classList.remove('highlight-value');
        
        draw();
    }

    function updateUI() {
        if (!isClosed) return;
        if (isGuessMode) {
            ui.a.textContent = "??";
            ui.n.textContent = "??";
            ui.s.textContent = "??";
            ui.s.classList.remove('highlight-value');
            ui.btnReveal.style.display = 'block';
        } else {
            showRealData();
            ui.btnReveal.style.display = 'none';
        }
    }

    function revealData() {
        showRealData();
        ui.btnReveal.style.display = 'none';
    }

    function showRealData() {
        // æ•°å­—æ»šåŠ¨ç‰¹æ•ˆ
        animateValue(ui.a, computedData.a);
        animateValue(ui.n, computedData.n);
        animateValue(ui.s, computedData.s);
        ui.s.classList.add('highlight-value');
    }
    
    function animateValue(obj, end) {
        obj.textContent = end; // ç®€å•èµ·è§ç›´æ¥æ˜¾ç¤ºï¼Œå¹³æ¿ä¸ŠåŠ¨ç”»è¿‡å¤šå¯èƒ½æ‰å¸§
    }

    // --- ç®—æ³•éƒ¨åˆ† (åŒä¸Šç‰ˆï¼Œä¿æŒä¸¥è°¨) ---
    function calculate() {
        const n = getBoundaryPoints();
        const s = getArea();
        const a = getInternalPoints();
        computedData = { a, n, s };
        updateUI();
    }

    function getBoundaryPoints() {
        let n = 0;
        for (let i = 0; i < points.length; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];
            n += gcd(Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y));
        }
        return n;
    }

    function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }

    function getArea() {
        let area = 0;
        for (let i = 0; i < points.length; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];
            area += p1.x * p2.y - p2.x * p1.y;
        }
        return Math.abs(area) / 2;
    }

    function getInternalPoints() {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (let p of points) {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
            minY = Math.min(minY, p.y);
            maxY = Math.max(maxY, p.y);
        }
        let count = 0;
        for (let x = minX + 1; x < maxX; x++) {
            for (let y = minY + 1; y < maxY; y++) {
                if (isPointInPolygon({x, y}, points)) count++;
            }
        }
        return count;
    }

    function isPointInPolygon(p, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[j].x, yj = polygon[j].y;
            if (isPointOnSegment(p, polygon[i], polygon[j])) return false;
            const intersect = ((yi > p.y) !== (yj > p.y)) &&
                (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function isPointOnSegment(p, a, b) {
        const crossProduct = (p.y - a.y) * (b.x - a.x) - (p.x - a.x) * (b.y - a.y);
        if (Math.abs(crossProduct) > Number.EPSILON) return false;
        const dotProduct = (p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y);
        if (dotProduct < 0) return false;
        const squaredLength = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y);
        return dotProduct <= squaredLength;
    }

    // å¯åŠ¨
    init();

</script>
</body>
</html>